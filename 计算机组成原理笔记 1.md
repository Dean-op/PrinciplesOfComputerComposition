# **Ⅰ 计算机系统概述**

## **1.2 计算机系统层次结构**

### **1.2.1 计算机硬件的基本组成**

#### 1.2.1.1 冯·诺依曼计算机的结构

​	虚线表示控制和状态反馈，实线表示数据通路

![image-20241020120226224](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120226224.png)



#### **1.2.1.2 现代计算机结构：**

![image-20241020120244325](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120244325.png)



- **==主存储器的基本构成==：**

-- 存储体-存储单元-存储元件（可类比大楼-房间-床位）
-- ==存储单元：存放一串二进制代码==
-- ==存储字：存储单元中二进制代码的组合==
-- ==存储字长：即存储单元中二进制代码的长度（存储字长度）==
-- ==**MAR:存储器地址寄存器，反应存储单元的个数**==
-- ==**MDR:存储器数据寄存器，反应存储字长**==

![image-20241020120303591](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120303591.png)



- **运算器的基本组成：**

![image-20241020120313973](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120313973.png)



**Q&A**

为什么MAR 能反映存储单元的个数？

MAR（Memory Address Register，内存地址寄存器）能够反映存储单元的个数，是因为它用于存储访问内存时的地址，而该地址的位数决定了可以寻址的存储单元数量。

具体来说：

1.地址位数与存储单元的关系

- - MAR的位数决定了它能够表示的地址范围。假设MAR有N位，那么它最多可以表示 ( 2^N ) 个不同的地址。这意味着可以访问 ( 2^N ) 个存储单元。

2.示例

- - 如果MAR是16位，那么它可以表示 ( $2^{16} = 65,536$ ) 个不同的地址。因此，系统可以访问65,536个存储单元（也就是64KB的内存）。
  - 如果MAR是32位，那么它可以表示 ($ 2^{32} = 4,294,967,296 $) 个地址，也就是可以访问4GB的内存。

3.总结

- - MAR的位数决定了系统能够寻址的存储单元数量。位数越多，能访问的存储单元也就越多。因此，MAR的位数反映了系统可以支持的最大存储单元数。





**控制器基本结构 ：**

1.==功能：解释指令、保证指令的按序进行==

完成一条指令需要：取指令 分析指令 执行指令

![image-20241020120436206](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120436206.png)

### ==**1.2.2 计算机硬件的工作原理**==



#### 1.“存储程序”工作方式

“存储程序”工作方式规定,程序执行前,需要将程序所含的指令和数据送入主存储器,一旦程序被启动执行，就无须操作人员的干预，自动逐条完成指令的取出和执行任务。如图 1.4 所示,一个程序的执行就是周而复始地执行一条一条指令的过程。每条指令的执行过程包括:从主存储器中取指令、对指令进行译码、计算下条指令地址、取操作数并执行、将结果送回存储器。

程序执行前，先将程序第一条指令的地址存放到 PC 中，取指令时，将 PC 的内容作为地址访问主存储器。在每条指令执行过程中,都需要计算下条将执行指令的地址,并送至PC。若当前指令为顺序型指令,则下条指令地址为PC的内容加上当前指令的长度;若当前指令为转跳型指令，则下条指令地址为指令中指定的目标地址。当前指令执行完后，根据 PC 的内容到主存储器中取出的是下一条将要执行的指令,因而计算机能周而复始地自动取出并执行一条一条的指令。

![image-20241020131138634](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020131138634.png)







#### 2.从源程序到可执行文件

pass

#### 3.指令执行过程的描述

pass





![image-20241020120514312](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120514312.png)



### **1.2.3 计算机系统的层次结构**

![image-20241020120542108](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120542108.png)



**计算机系统的层次结构：**

<img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120554699.png" alt="image-20241020120554699" style="zoom:50%;" />





**三个级别的语言：**

编译程序：将高级语言编写的源程序全部语句一次全部翻译成机器语言程序，而后再执行机器语言程序（==只需翻译一次==)

解释程序:将源程序的一条语句翻译成对应的机器语言的语句,并立即执行。紧接着再翻译下一句(==每次执行都要翻译==)

以下是机器语言、汇编语言和高级语言的对比表格：



| **特性**       | **机器语言**                         | **汇编语言**                                 | **高级语言**                                |
| -------------- | ------------------------------------ | -------------------------------------------- | ------------------------------------------- |
| **抽象层次**   | 最低（直接与硬件交互）               | 低（与硬件紧密关联）                         | 高（接近人类语言，跨平台）                  |
| **表示形式**   | 二进制代码（0和1）                   | 助记符（如MOV、ADD等）                       | 类似自然语言或数学符号的语句（如if、for等） |
| **执行效率**   | 最高                                 | 高                                           | 较高（需要通过编译器或解释器转换）          |
| **易读性**     | 极低（难以理解和调试）               | 低（需要了解硬件细节）                       | 高（易于阅读、编写和维护）                  |
| **平台依赖性** | 高（与特定处理器架构紧密相关）       | 高（依赖于特定的硬件架构）                   | 低（通常可跨平台）                          |
| **开发效率**   | 最低（编写复杂、耗时）               | 较低（相比机器语言有所改进，但仍需硬件知识） | 最高（大幅提高开发效率）                    |
| **使用场景**   | 硬件驱动、嵌入式系统中的极端性能优化 | 系统软件、驱动程序、嵌入式开发               | 应用软件、跨平台开发、大规模软件项目        |

<img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120612568.png" alt="image-20241020120612568" style="zoom:50%;" />





## **1.3 计算机的主要性能指标**

![image-20241020120624818](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120624818.png)



### **字长**

==字长指的是CPU在一次操作中能够处理的二进制位数。==它通常代表CPU寄存器的宽度和指令集架构的基本操作单位。典型的字长有8位（8-bit），16位（16-bit），32位（32-bit），64位（64-bit）等。字长越长，系统能够直接寻址的内存空间也越大。例如，32位的系统最多可以寻址4GB的内存，而64位系统可以寻址理论上的16EB

### **数据通路带宽**

==是指数据总线一次所能并行传送信息的位数。==数据通路带宽决定了每次内存与CPU之间或其他部件之间能够传输的数据量。例如，一个系统的数据总线带宽是32位，则它一次可以传输32位（4字节）数据。如果是64位的数据总线，则可以一次传输64位（8字节）数据。

### 主存容量

<img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120639851.png" alt="image-20241020120639851" style="zoom:50%;" />

### **运算速度**

**(1) 吞吐量和响应时间**

- ==吞吐量：单位时间内系统能够处理的请求数量。==对于CPU而言，吞吐量通常是每秒钟执行的指令数（Instructions Per Second，IPS）或浮点运算次数（FLOPS）。在多用户或并发任务场景下，吞吐量反映了系统的整体处理能力。示例：如果一台服务器每秒可以处理100个请求，那么它的吞吐量就是100请求/秒
- 响应时间：响应时间是指从发出请求到接收到系统响应之间的时间。

**(2) 主频和CPU时钟周期**

- ==CPU时钟周期：时钟周期是CPU内部完成一项操作的最小时间单位。**主频的倒数。CPU中最小的时间单位。**==示例：如果一个CPU的主频为2GHz，那么它的时钟周期是1/2GHz = 0.5纳秒（ns）。
- ==主频：主频是CPU数字脉冲信号的震荡频率，通常以GHz（千兆赫）为单位表示。==它表示CPU每秒可以完成的时钟周期数。较高的主频通常意味着CPU每秒能完成更多的指令，但不一定反映整体性能。

(3) **CPI**：==执行一条指令所花费的时钟周期数。==

(4) **CPU执行时间**：执行一个程序所花费的时间。==**CPU执行时间（整个程序的耗时）= CPU时钟周期数/主频= （指令条数\*CPI） /主频。 类比:时间=路程/速度**==

<img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120652227.png" alt="image-20241020120652227" style="zoom:50%;" />





==**意CPU的性能(执行时间)取决于三个要素：主频、CPI、指令条数**==



**(5)IPS与FLOPS**

- IPS （Instructions Per Second）:每秒执行多少条指令。
- FLOPS （Floating-point Operations Per Second） :每秒执行多少浮点运算。

<img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120702785.png" alt="image-20241020120702785" style="zoom:50%;" />

### **基准程序**

基准程序是用来测量计算机处理速度的一种实用程序,以便于被测量的计算机性能可以与运行相同程序的其它计算机性能进行比较。









# **Ⅱ 数据的表示和运算**

## **2.1 数制与编码**

### **2.1.1 进位计数制及其相互转换**

![](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020111002874.png)

#### **1) r进制计数法**

基数：每个数码位所用到的不同符号的个数，r进制的基数为r。

==在进位计数法中，每个数位所用到的不同数码的个数称为基数。==十进制的基数为10 (0~9)，每个数位计满 10就向高位进位，即“逢十进一”。

==每个数码所表示的数值等于该数码本身 乘以一个与它所在数位有关的常数,这个常数称为位权==。一个进位数的数值大小就是它的各位数码按权相加。
$$
\text{一个 }r\text{ 进制数(}K_nK_{n-1}...K_0K_{-1}...K_{-m}\text{)的数值可表示为}\\K_{n}r^{n}+K_{n-1}r^{n-1}+\cdots+K_{0}r^{0}+K_{-1}r^{-1}+\cdots+K_{-m}r^{-m}=\sum_{i=n}^{-m}K_{i}r^{i}
$$
$\text{式中,}r\text{ 是基数;}r^j\text{ 是第 }i\text{ 位的位权;}K_i\text{的取值可以是 }0,1,\cdots,r-1\text{ 共 }r\text{ 个数码中的任意一个。}$



例如任意进制转十进制
$$
二进制：$101.1->1\times2^{2}+0\times2^{0}+1\times2^{-1}=5.5$\\

八进制：$5.4->5\times8^{0}+4\times8^{-1}=5.5$\\

十进制：$5.5->5\times10^{0}+5\times10^{-1}=5.5$ \\

十六进制：$5.8->5\times16^0+8\times16^{-1}=5.5$
$$


#### **2）任意进制转十进制与十进制转任意进制**

<img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020112843149.png" alt="image-20241020112843149" style="zoom: 80%;" />

![image-20241020112902004](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020112902004.png)

可以用后缀字母标识一个数的进位计数制，==用 B 表示二进制，用O 表示八进制，用 D 表示十进制（通常直接省略），用 H 表示十六进制，有时也用前缀 0x 表示十六进制数。==



#### **3) 二进制转八进制、十六进制**

1. 对于一个二进制混合数(既包含整数部分，又包含小数部分)，在转换时应以小数点为界。
2. ==其整数部分，从小数点开始往左数，将一串二进制数分为3 位（八进制）一组或4 位（十六进制）一组，在数的最左边可根据需要加“0”补齐；==
3. ==对于小数部分，从小数点开始往右数，也将一串二进制数分为 3 位一组或 4 位一组，在数的最右边也可根据需要加“0”补齐。==
4. 最终使总的位数为3 或 4 的整数倍，然后分别用对应的八进制数或十六进制数取代。

<img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020114246189.png" alt="image-20241020114246189" style="zoom: 80%;" />



同样,==由八进制数或十六进制数转换为二进制数,只需将每位改为3位或4位二进制数即可(必要时去掉整数最高位或小数最低位的0)。==

八进制数和十六进制数之间的转换也能方便地实现，十六进制数转换为八进制数(或八进制数转换为十六进制数)时,先将十六进制(八进制)数转换为二进制数,然后由二进制数转换为八进制(十六进制)数较方便。

#### **4) 十进制小数转换为二进制小数**

一个十进制数转换为任意进制数，通常采用基数乘除法。这种转换方法对十进制数的整数部分和小数部分将分别进行处理，==对整数部分采用除基取余法，对小数部分采用乘基取整法，==最后将整数部分与小数部分的转换结果拼接起来。

1. **除基取余法（用于整数部分）**

​		**除基取余法**用于将十进制数的**整数部分**转换为任意进制数。

- ==**步骤**：==
  
  1. ==用十进制数除以目标进制的基数。==
  2. ==记录每次除法得到的**余数**，作为目标进制中的一位数。==
  3. ==将除法得到的商继续除以基数，重复上述步骤，直到商为零。==
  4. ==逆序排列所有余数，得到转换后的进制数。==
  
- **示例**：
  将十进制数 **45** 转换为 **二进制**：
  $$
  1:45 \div 2 = 22 , 余数为 1\\
  2:22 \div 2 = 11 , 余数为 0\\
  3:11 \div 2 = 5 , 余数为 1\\
  4:5 \div 2 = 2 , 余数为 1\\
  5:2 \div 2 = 1 , 余数为 0\\
  6:1 \div 2 = 0 , 余数为 1
  $$
  逆序排列余数：**101101**。所以，十进制数45的二进制表示为 **101101**。

2. **乘基取整法（用于小数部分）**

​		**乘基取整法**用于将十进制数的**小数部分**转换为任意进制数。

- ==**步骤**：==
  
  1. ==用小数部分乘以目标进制的基数。==
  2. ==记录每次乘法结果的**整数部分**，作为目标进制中的一位小数。==
  3. ==将乘法结果的小数部分继续乘以基数，重复上述步骤，直到小数部分为零（或达到所需精度）。==
  4. ==顺序排列所有的整数部分，得到小数的转换结果。==
  
- **示例**：
  将十进制小数 **0.625** 转换为 **二进制**：
  $$
  1: 0.625 \times 2 = 1.25  , 整数部分为  1 ，小数部分为  0.25 \\
  2: 0.25 \times 2 = 0.5  , 整数部分为  0 ，小数部分为  0.5 \\
  3: 0.5 \times 2 = 1.0  , 整数部分为  1 ，小数部分为  0
  $$
  顺序排列整数部分：**101**。所以，十进制小数0.625的二进制表示为 **0.101**。

将整数部分的转换结果与小数部分的转换结果拼接在一起，得到完整的进制转换结果。

例如，十进制数 **45.625** 转换为二进制数：

- 整数部分：**101101**
- 小数部分：**0.101**

结果为：**101101.101**。

**总结**

- ==**除基取余法**用于整数部分，通过反复除以目标基数取余来获取进制数的各位，结果按逆序排列。==
- ==**乘基取整法**用于小数部分，通过反复乘以目标基数取整数来获取进制数的小数部分，结果按顺序排列。==



注意：在计算机中,小数和整数不一样,整数可以连续表示==,但小数是离散的,所以并不是每个十进制小数都可以准确地用二进制表示==。例如0.3,无论经过多少次乘二取整转换都无法得到精确的结果。但任意一个二进制小数都可以用十进制小数表示,希望读者引起重视。





### ==**2.1.2 定点数的编码表示**==

#### 2.1.2.1 真值和机器数

在日常生活中==,通常用正号、负号来分别表示正数(正号可省略)和负数,如+15、-8等。这种带“+”或“-”符号的数称为真值。==真值是机器数所代表的实际值。

==在计算机中，通常将数的符号和数值部分一起编码，将数据的符号数字化，通常用“0”表示“正”，用“1”表示“负”。这种把符号“数字化”的数称为机器数。==常用的有原码、补码和反码表示法。如 0,101(这里的逗号“，”仅为区分符号位与数值位)表示+5。

#### 2.1.2.2 机器数的定点表示

==根据小数点的位置是否固定，在计算机中有两种数据格式：定点表示和浮点表示。==

在现代计算机中，==通常用补码整数表示整数，用原码小数表示浮点数的尾数部分，用移码表示浮点数的阶码部分，==历年统考真题的命题信息也主要落在这个范畴之内。

1)定点小数。定点小数是纯小数，==约定小数点位置在符号位之后、有效数值部分最高位之前。==若数据$X$的形式为 $X=x_0.x_1x_2...x_n$ (其中 $x_0$ 为符号位，$x_1\sim x_n$ 是数值的有效部分，也称==尾数==，$x_1$为最高有效位),则在计算机中的表示形式如图 2.1 所示。

2)定点整数。==定点整数是纯整数，约定小数点位置在有效数值部分最低位之后。==若数据$X$的形式为$X=x_0,x_1x_2...x_n$(其中 $x_0$为符号位，$x_1\sim x_n$ 是尾数$x_n$ 为最低有效位),则在计算机中的表示形式如图 2.2 所示。

![image-20241022163606734](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241022163606734.png)

事实上,在机器内部并没有小数点，只是人为约定了小数点的位置。因此，在定点数的编码和运算中不用考虑对应的定点数是小数还是整数，而只需关心它们的符号位和数值位即可。





#### ==2.1.2.3 原码、补码、反码、移码==

定点数的编码表示法主要有以下4 种:原码、补码、反码和移码。

习题课[2-3-6 定点数的编码—习题课_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1qG41197E4?p=17)

##### 1)原码表示法

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241023081332276.png" alt="image-20241023081332276" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

**定点整数源码表示:**==用机器数的最高位表示数的符号，其余各位表示数的绝对值。==

原码在计算机中目前仅仅用于表示浮点数的尾码

<img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241022175304853.png" alt="image-20241022175304853" style="zoom: 50%;" />
$$
[ x ]_{\mathrm{原}}=\left\{\begin{matrix} {{{0, x}}} & {{{0 \leqslant x < 2^{n}}}} \\ {{{2^{n}-x=2^{n}+| x |,}}} & {{{-2^{n} < x \leqslant0}}} \\ \end{matrix} \right.  ——( x 是真值，字长为 n+1 )
$$


<img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241022180303999.png" alt="image-20241022180303999" style="zoom:50%;" />

例如，若 $x_{1}=+1 1 1 0, \ x_{2}=-1 1 1 0$ ，字长为8位，则其原码表示为 $[ x_{1} ]_{原}=0, 0 0 0 1 1 1 0, \ [ x_{2} ]_{原}=2^{7}+$  $1 1 1 0=1, 0 0 0 1 1 1 0$ ，其中最高位是符号位。

==若字长为 $n+1$ ，则原码整数的表示范围为 $- ( 2^{n}-1 ) \leqslant x \leqslant2^{n}-1$ (关于原点对称）。==



**定点小数源码表示:**

<img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241022181059733.png" alt="image-20241022181059733" style="zoom:70%;"/>



**==零的原码表示有正零和负零两种形式,即[+0]= 0.0000000和[-0] = 1.0000000==**







##### 2)补码表示法

分为定点整数和定点小数的补码表示



- 模的概念模(或称模数)
  - 是一个数值计量系统的计量范围，记作mod或M。
  - ==只要确定了“模”,就可找到一个与负数等价的正数来代替此负数,该正数就是负数的补数。==
  - ==超过计量范围的数都应该自动**舍弃模数。**==
- 补数的特点
  - **==一个负数可用它的正补数来替代,而这个正补数可以用模数加上负数本身求得。==**
  - **==一个正数和一个负数互为补数时，它们绝对值之和即为模数。==**
  - **==正数的补数即该正数本身。==**
- **补码和真值的相互转换**
  - **真值转换为补码:对于正数,与原码的方式一样。==对于负数,符号位取1,其余各位由真值“各位取反,末位加1”得到。==**
  - **补码转换为真值:若符号位为0,与原码的方式一样。==若符号位为1,真值的符号为负,数值部分各位由补码“各位取反,末位加1”得到。==**


<div style="text-align: left; zoom: 70%;">
  <img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241022222910807.png" alt="image-20241022222910807" >
</div>

将补数的概念应用到计算机内部,便出现了补码这种机器码(机器数)。

- 正数的补码:符号位为0,数值位就是它本身。
- ==负数的补码：**等于模数加上该负数本身**，而模数就是最高位进位的位权值。==**==也可以利用原码(除符号位)取反+1来快速计算==**



<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241023085322607.png" alt="image-20241023085322607" width="85%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

利用原码(除符号位)取反+1来快速计算:

$[x] = -10101$
$[x]_{原} = 10010101$
$[x]_{原}取反加1 = 11101010 + 1 = 11101011$



$$
例子: 某计算机的字长为8位，真值x为定点整数-128，求[x]_补。\\
[x]_补 = 2^8 + (-128)=1\ 0000\ 0000\ -\ 1000\ 0000\ = 1,000\ 0000
$$



<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241023084628251.png" alt="image-20241023084628251" width="85%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>





注意：因为-128和-1.0000000的补码形式相同，所以现代计算机中多==采用IEEE 754标准表示浮点数，而其中的**定点小数采用原码表示**，因此通常不会涉及定点小数的补码表示。==

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241023085642831.png" alt="image-20241023085642831" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241023090746200.png" alt="image-20241023090746200" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>



总结：

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241023091646163.png" alt="image-20241023091646163" width="85%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

例题：

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241026155159048.png" alt="image-20241026155159048" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241026155411153.png" alt="image-20241026155411153" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>



##### **3)反码表示法**

反码通常用来作为由原码求补码或者由补码求原码的中间过渡。

- ==正数的反码：符号位为0，数值位就是它本身。==
- ==负数的反码：符号位为1，数值位就是真值数值位取反。==



<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241023093201887.png" alt="image-20241023093201887" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>



<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241023094244638.png" alt="image-20241023094244638" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>



==真值0在反码中有两种不同的表示：$0.0000$ 和 $1.1111$==

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241023215155100.png" alt="image-20241023215155100" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>





**三种码制对比：**

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241023222647622.png" alt="image-20241023222647622" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241023095203951.png" alt="image-20241023095203951" width="85%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>







##### 4)移码表示法

移码就是在真值上加一个常数$2^n$。

- 在数轴上,移码所表示的范围对应于真值在数轴上的范围向轴的正方向移动$2^n$个单元。
- ==移码只用于定点整数的表示。==

例如，若正数 $x_{1}=+1 0 1 0 1, \ x_{2}=-1 0 1 0 1$ ，字长为 $8$ 位，则其移码表示为 $[ x_{1} ]_{\mathbb{移}}=2^{7}+1 0 1 0 1=1 , 0010101$； $[ x_{2} ]_{移}=2^{7}+(-1 0 1 0 1 )=0, \, 1 1 0 1 0 1 1$ 。

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241023221900498.png" alt="image-20241023221900498" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>



**移码具有以下特点：**
① 移码中零的表示唯一， $[+0 ]_{移}=2^{n}+0=[-0 ]_{移}=2^{n}-0=100... 0\\$ (n个0) $ 。
$

② ==一个真值的移码和补码仅差一个符号位， $[ x ]_{\mathbb{补}}$ 的符号位取反即得 $[ x ]_{\mathbb{移}} $（1表示正，0表示负），这与其他机器数的符号位取值正好相反，反之亦然==。
③ 移码全0时，对应真值的最小值 $- 2^{n}$ ；移码全1时，对应真值的最大值 $2^{n} \!-\! 1$ 。
④移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小。



##### 5)各种码之间的转换

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241023224431270.png" alt="image-20241023224431270" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

**==各种码的转换关系：==**

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241023224524901.png" alt="image-20241023224524901" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>





==真值x为负数，原码和补码快速互相转换：==

扫描法：

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241023224741398.png" alt="image-20241023224741398" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>



==$[x]_补 和 [-x]_补快速互相转化:$==

**全部位按位取反,末位加1**

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241023225302655.png" alt="image-20241023225302655" width="65%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>









#### ==2.1.2.4 定点数加减法==

| 导航                        | **内容**                                                     |
| --------------------------- | ------------------------------------------------------------ |
| **2.1.2.4 定点数加减法**    |                                                              |
| **1) 定点数加减法公式**     | - 加法：$$ [A]_补 + [B]_补 = [A]_补 + [B]_补 $$ <br>- 减法：$$ [A]_补 - [B]_补 = [A - B]_补 = [A]_补 + [-B]_补 $$ |
| **2) 定点数加减法溢出检测** |                                                              |
| **溢出产生原因**            | - 由于计算机字长有限，运算结果超出所能表示的数据范围时会产生溢出（Overflow），导致错误结果。 |
| **溢出检测方法**            | - **方法 1（符号位法）：** <br>根据操作数的符号位与运算结果的符号位是否一致进行判断<br> $$ OF = x_{n-1} \cdot y_{n-1} \cdot \overline{s}_{n-1} + \overline{x}_{n-1} \cdot \overline{y}_{n-1} \cdot s_{n-1} $$ <br>当 $OF = 1$ 时，表示溢出。 |
|                             | - **方法 2（进位法）：** <br> 根据最高数值位进位 $C_{n-1}$ 与符号位进位 $C_n$ 是否一致判断溢出：<br> $$ OF = C_{n-1} \oplus C_n $$ <br>当 $OF = 1$ 时，表示溢出。 |
|                             | - **方法 3（变形补码法）：** <br>利用双符号位（$C_{n+1}$ 和 $C_n$）判断溢出：<br> - 双符号位为 `00` 表示正数；<br> - 双符号位为 `11` 表示负数；<br> - 双符号位为 `01` 表示正溢出；<br> - 双符号位为 `10` 表示负溢出。<br> $$ OF = C_{n+1} \oplus C_n $$ |



##### **==1) 定点数加减法计算公式：==**

==$$ [A]_补 + [B]_补 = [A]_补 + [B]_补 $$==
==$$ [A]_补 - [B]_补 = [A - B]_补= [A]_补 + [ - B]_补$$==

$$\text{(mod M)} \begin{cases} \textbf{定点整数}: M = 2^{n+1} \text{ 其中, } n \text{ 为补码数值位的位数} \\ \textbf{定点小数}: N = 2^1 = 2 \end{cases} $$

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241126101644024.png" alt="image-20241126101644024" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>



##### **==2) 定点数加减法溢出检测：==**

- 计算机的字长是有限的，因此所能表示的数据范围也是有限的。
- 当运算结果超出所能表示的数据范围时，就会出现溢出（Overflow）。溢出会导致错误的运算结果。

判断溢出方法：

- **==方法1根据操作数的符号位与运算结果的符号位是否一致进行判断（常用）==**
- ==方法2根据运算过程中最高数值位的进位与符号位的进位是否一致进行判断==
- ==方法3利用变形补码（具有2位符号位的补码）的符号位进行判断==



**方法一：**

操作数 $x$ 的符号位记为 $x_{n-1}$，操作数 $y$ 的符号位记为 $y_{n-1}$，运算结果 $s$ 的符号位记为 $s_{n-1}$ ，溢出标志位记为 $OF$，当 $OF$ 为 $1$ 时表示发生溢出。

==$$ O F = x_{n-1} \cdot y_{n-1} \cdot \overline{s}_{n-1} + \overline{x}_{n-1} \cdot \overline{y}_{n-1} \cdot S_{n-1} $$==


<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241126154022461.png" alt="image-20241126154022461" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

**方法二：**

根据运算过程中最高数面位的相位与符号位的相位是否一致进行判断不同可判定为产生溢出，相同可判定为:没有产生溢出。

==最高数值位的进位记为 $C_{n-1}$ ，符号位的进位记为 $C_n$，溢出标志位记为$OF$，当$OF$为1时表示发生溢出。==

==$C_{n-1}$ 与 $C_n$ 不同，则产生溢出（即OF为1）：$$ 0 F = Cn-1 \oplus Cn $$==

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/imageimage-20241126183954529.png" alt="image-20241126183954529" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>



**方法三：**

利用变形补码（具有2位符号位的补码）的符号位进行判断

==双符号位为 00 时，表示正数；双符号位为 11时，表示负数；==

==双符号位为 01 时，表示正溢出；双符号位为10时，表示负溢出；==

$ 在起第一个符号位记为 C_{n+1}在起第二个符号位记为 C_n溢出标志位记为 OF，当 OF 为1时表示发生溢出。$

==$C_{n+1} 与 C_n 不同，则产生溢出（即 OF 为1）：OF = C_{n+1} \oplus C_n $==

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/imageimage-20241126184730878.png" alt="image-20241126184730878" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>





<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/imageimage-20241126195714054.png" alt="image-20241126195714054" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>





<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/imageimage-20241126195603475.png" alt="image-20241126195603475" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/imageimage-20241126195351079.png" alt="image-20241126195351079" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>



#### 2.1.2.5 定点数乘除法











### **2.1.3 C语言中的数据类型及转换**

[2-5 C语言中的数据类型及转换_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1qG41197E4?p=21)

- 计算机中的数据以二进制的形式存储在寄存器或存储器中。
- 汇编语言中的数据类型取决于指令操作码。
  - 存储在寄存器、存储器中的操作数本身没有数据类型,对该数进行何种数据类型的操作完全取决于指令。
  - 同一个操作数，既可以当作有符号数,也可以当作无符号数；既可以是定点数,也可以是浮点数。
- 高级语言具有数据类型，下面以C语言为例进行介绍。

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027201716509.png" alt="image-20241027201716509" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027204026668.png" alt="image-20241027204026668" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>





C语言中整型数据之间的转换：

- 相同字长之间的转换
- 小字长转大字长
- 大字长转小字长



#### 2.1.3.1 相同字长之间的转换

8位char——unsigned char

16位short——unsigned short

32 位int——unsigned int

64位long——unsigned long

==在计算机中，有符号数通常使用**补码**来存储，而无符号数则直接使用**原码**（二进制形式）来存储。==

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027210238428.png" alt="image-20241027210238428" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027210348381.png" alt="image-20241027210348381" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>











#### 2.1.3.2 小字长转大字长

- 若原数值为无符号数值，则转换后的数据与原数值相同。
- ==若原数值为有符号数值，则转换后的数据与原数值有可能不同。==

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241030092854595.png" alt="image-20241030092854595" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241030093307713.png" alt="image-20241030093307713" width="35%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>



#### 2.1.33 大字长转小字长



























### ==**2.1.4 浮点数的表示与运算**==

#### 2.1.4.1 浮点数的表示方法和表示范围

回顾定点数：

在计算机中，==定点小数主要用于表示浮点数的尾数==，并没有高级语言数据类型与之相对应。

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241026164241564.png" alt="image-20241026164241564" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241026164658330.png" alt="image-20241026164658330" width="85%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>



定点数所能表示的数据范围与下列因素有关：

- 机器字长：字长越长，其表示的数据范围就越大。
- 所采用的机器码：==补码和移码所能表示的数据范围,比原码和反码所能表示的数据范围要多一个最小负数。==



**浮点数的表示方法：**

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241026175502418.png" alt="image-20241026175502418" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

- ==浮点数的基数指的是数值表示的底数。在计算机中，常用的基数是2（对于二进制浮点数）==，也可以是10（十进制浮点数）或16（十六进制浮点数）。
- ==阶码用于表示浮点数的大小和范围，它决定了尾数的实际值的放大或缩小程度==。在浮点数表示中，阶码通常以偏移量的形式存储。偏移量（Bias）是一个常数，用于使阶码为负的情况下也能表示为非负数。例如，在单精度浮点数（32位）中，阶码部分为8位，偏移量为127。因此，实际的阶码值为存储值减去127。
  - ==**阶码的位数决定了数据表示的范围，位数越多，能表示的数据范围就越大。**==
  - ==**阶码的值决定了小数点的位置。**==
- ==尾数表示浮点数的有效数字部分。==它通常以小数形式表示，且其前面有一个隐含的基数（通常是1）。在二进制浮点数中，尾数的最高位通常是1，这个1在表示时是隐含的。
  - ==**尾数的位数决定了数据的表示精度。阶码长度相同时,分配给尾数的位数越多,数据表示的精度就越高。**==
  - **==阶码为定点整数而尾数为定点小数==**



表示公式：
$$
\begin{align*}
\text{Value} = (-1)^{\text{sign}} \times \text{mantissa} \times \ base^{exponent}
\end{align*}
$$

- sign 表示符号位（0为正数，1为负数）。
- mantissa 是尾数部分。
- base 是基数（例如2）。
- exponent 是经过偏移处理的阶码。

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241026182846823.png" alt="image-20241026182846823" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>





**浮点数的表示范围：**

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241026190601999.png" alt="image-20241026190601999" width="85%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

> **尾数部分最大值推导：**
>
> $在浮点数表示法中，尾数部分通常是一个小数，其值范围在 [1, 1 - 2^{-n}] 之间，其中 \( n \) 表示尾数部分的有效位数。我们来推导为什么 \( 1 - 2^{-n} \) 是尾数部分的最大值。$
>
> 1. 尾数的表示形式
>
> 尾数通常被表示成一个带有隐含整数部分的二进制小数。比如，对于二进制浮点数，尾数部分的数值范围是从 1 到接近于 2（但小于 2），这在二进制形式中表现为 \( 1.xxxx...x \)，其中小数点后有 \( n \) 位二进制数。
>
> 二进制尾数的小数部分
>
> $假设尾数的小数部分有 \( n \) 位，可以用 \( M = 1.M_1 M_2 M_3 \dots M_n \) 表示， 其中每一位 \( M_i \) 是 0 或 1。$
>
> 2. 最大值的推导
>
> $尾数的最大值出现在每个小数位 \( M_i \) 都取最大值，即所有位都为 1 的情况下。$
> 尾数 \( M \) 可以表示为：
> $M = 1 + \frac{M_1}{2} + \frac{M_2}{2^2} + \frac{M_3}{2^3} + \dots + \frac{M_n}{2^n}$
>
> 当每一位 \( M_i = 1 \) 时，尾数的值达到最大，即：
> $M = 1 + \frac{1}{2} + \frac{1}{2^2} + \frac{1}{2^3} + \dots + \frac{1}{2^n}$
>
> 这实际上是一个有限的等比数列求和。
>
> 3. 等比数列求和
>
> 这个等比数列的和为：
> $M = 1 + \left( \frac{1}{2} + \frac{1}{2^2} + \frac{1}{2^3} + \dots + \frac{1}{2^n} \right)$
>
> 等比数列求和公式为：
> $\text{Sum} = a \frac{1 - r^n}{1 - r}$
> $其中，首项 \( a = \frac{1}{2} \)，公比 \( r = \frac{1}{2} \)，项数为 \( n \)。$
>
> 代入得到：
> $\text{Sum} = \frac{1}{2} \cdot \frac{1 - \left( \frac{1}{2} \right)^n}{1 - \frac{1}{2}} = 1 - \frac{1}{2^n}$
>
> 所以，尾数的最大值为：
> $M = 1 - 2^{-n}$
>
> 

- 尽管浮点数有效扩大了数据表示范围，但受机器字长限制，浮点数仍然存在==溢出现象==。
  - 当==浮点数的阶码大于最大阶码时,称为**上溢**,此时机器**停止运算**,==浮点运算器件会显示溢出标志。
  - 当==浮点数的阶码小于最小阶码时,称为**下溢,**虽然此时数据不能被精确表示,但由于发生下溢时数据的绝对值很小，通常将尾数各位强置为0，按机器0处理，此时机器**可以继续运行**。==
- 当一个浮点数在正、负数区域中但并不在某个数轴刻度上时,也会出现精度溢出的问题,此时只能用近似数表示。

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027123133088.png" alt="image-20241027123133088" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241026205901501.png" alt="image-20241026205901501" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241026210306853.png" alt="image-20241026210306853" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>









#### 2.1.4.2 浮点数的规格化

为了在浮点数运算过程中尽可能多地保留有效数字的位数，使有效数字尽量占满尾数数位，必须在运算过程中对浮点数进行规格化操作。==所谓规格化操作,是指通过调整一个非规格化浮点数的尾数和阶码的大小,使非零浮点数**在尾数的最高数位上保证是一个有效值。**==

- 左规:当运算结果的尾数的最高数位不是有效位,即出现±0.0...0x...x的形式时,需要进行左规。==左规时,尾数每左移一位、阶码减1 (基数为2时),==左规可能要进行多次。
- 右规:当运算结果的尾数的有效位进到小数点前面时,需要进行右规,右规只需进行一次。==将尾数右移一位、阶码加1 (基数为2时),右规时,阶码增加可能导致溢出。==



浮点数规格化带来以下好处：==**使浮点数的表示形式唯一。使浮点数的表示精度最高。**==



<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027123916055.png" alt="image-20241027123916055" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027002228583.png" alt="image-20241027002228583" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241026224526929.png" alt="image-20241026224526929" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241026223757734.png" alt="image-20241026223757734" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>



==基数r越大，可表示的浮点数范围越大，而且所表示的数的个数越多。但浮点数的精度反而下降。==

**例题：**

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027000305756.png" alt="image-20241027000305756" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027000843330.png" alt="image-20241027000843330" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>



<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027001313349.png" alt="image-20241027001313349" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>



<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027001942552.png" alt="image-20241027001942552" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027113742867.png" alt="image-20241027113742867" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>





#### 2.1.4.3 浮点数的标准

在 IEEE 754 中，一个浮点数由三个部分组成：

- **符号位 (sign)**：决定浮点数的正负，0 表示正数，1 表示负数。
- **阶码 (exponent)**：用于表示数的范围，通常是带==偏移==的二进制整数。
- **尾数 (mantissa 或 significand)**：表示数的精度，通常是一个小数。



<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027110008534.png" alt="image-20241027110008534" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

- 符号:   取值0表示正数;取值1表示负数。
- **==阶码：定点整数，用移码表示。==**
- **==尾数：定点小数，用原码表示。==**



==$在 IEEE 754 标准中，指数用移码表示，但偏置值是 2^{n-1} - 1 $。**记住即可**==

$因此，单精度和双精度浮点数的偏置值分别为 127 和 1023。在存储浮点数阶码之前，偏置值要先加到阶码真值上。$

$上例中，阶码值为 3，因此在单精度浮点数中，移码表示的阶码为 127 + 3 = 13(82H)；在双精度浮点数中，阶码为 1023 + 3 = 1026 (402H)。$





**下面是对==偏置值==的解释：**

> - 在 IEEE 754 浮点数标准中，**偏移量 (Bias)** 是一个用于阶码的关键概念。==通过偏移量，IEEE 754 可以用无符号的方式存储带符号的阶码值，避免了负数存储的复杂性，同时简化了硬件实现。==
>
>   #### 1. 为什么要使用偏移量？
>
>   使用偏移量的主要目的是：
>
>   - **解决符号问题**：阶码可能是正数或负数。直接用二进制存储负数需要额外处理，增加了复杂性。而使用偏移量可以把阶码全部转换成非负数存储。
>   - **便于排序和比较**：偏移量让数值的阶码表示具有单调性，即越大的数阶码越大，方便了硬件的比较和排序操作。
>
>   #### 2. 偏移量的计算
>
>   偏移量通常根据阶码的位数来确定，其计算方式如下：
>
>   - **单精度浮点数**（32 位）：阶码占 **8 位**，偏移量为 $ 2^{8-1} - 1 = 127 $。
>   - **双精度浮点数**（64 位）：阶码占 **11 位**，偏移量为 $ 2^{11-1} - 1 = 1023 $。
>
>   ==因此，偏移量的计算公式是：==
>   ==$
>   \text{Bias} = 2^{k-1} - 1
>   $==
>   ==其中 $ k $ 是阶码的位数。==
>
>   #### 3. 使用偏移量后的阶码范围
>
>   ==假设阶码为 $ e $，那么浮点数实际的阶码 $ E $ 计算方式为：==
>   ==$
>   E = e - \text{Bias}
>   $==
>
>   ##### 单精度（8 位阶码，偏移量为 127）
>
>   - 阶码 $ e $ 取值范围：0 到 255。
>   - 实际阶码 $ E $ 范围：
>     - 最小值：$ E_{\text{min}} = 0 - 127 = -127 $
>     - 最大值：$ E_{\text{max}} = 255 - 127 = 128 $
>
>   ##### 双精度（11 位阶码，偏移量为 1023）
>
>   - 阶码 $ e $ 取值范围：0 到 2047。
>   - 实际阶码 $ E $ 范围：
>     - 最小值：$ E_{\text{min}} = 0 - 1023 = -1023 $
>     - 最大值：$ E_{\text{max}} = 2047 - 1023 = 1024 $
>
>   #### 4. 偏移量的作用示例
>
>   以单精度（32 位）浮点数为例：
>
>   - 如果存储的阶码 $ e = 127 $：
>     $
>     E = 127 - 127 = 0
>     $
>     此时浮点数表示的是 $ 1 \times 2^0 = 1 $。
>
>   - 如果存储的阶码 $ e = 130 $：
>     $
>     E = 130 - 127 = 3
>     $
>     此时浮点数表示的是 $ 1 \times 2^3 = 8 $。
>
>   - 如果存储的阶码 $ e = 124 $：
>     $
>     E = 124 - 127 = -3
>     $
>     此时浮点数表示的是 $ 1 \times 2^{-3} = 0.125 $。
>
> 
>
> 
>
>   **举例中的 $1 \times 2^3 = 8$。 这里的1代表着什么？怎么来的**
>
> 
>
>   在 IEEE 754 标准中==，浮点数的尾数部分（即 **有效位** 或 **尾数**）采用了一种“隐含的 1”机制。具体来说，**规格化浮点数**的尾数（mantissa 或 significand）总是以 **1 开头**。这使得我们不需要显式存储这个 1，可以腾出更多位来存储小数部分，从而提高了精度。==
>
>   #### 1. 隐含的 1 的来源
>   在 IEEE 754 标准的规格化浮点数表示中：
>   - ==规格化数的尾数是介于 **1 到 2 之间的数**。==
>   - 因此，我们可以假设尾数的整数部分始终为 1，不必显式存储它。
>
>   这就是为什么在计算规格化浮点数的值时，尾数部分会默认是 **1.xxxxxx** 的形式，其中 `xxxxxx` 表示小数部分。
>
>   #### 2. 示例
>   假设一个单精度浮点数的二进制表示为：
>   ```
>   1 10000001 10100000000000000000000
>   ```
>   - **符号位**：1，表示负数。
>   - **阶码**：10000001（十进制 129）。
>   - **尾数**：`10100000000000000000000`。
>
>   根据 IEEE 754 规则：
>   1. **阶码计算**：129 - 偏移量 127 = 2。
>   2. **尾数还原**：隐含的 1 + `0.101` = **1.101**（尾数部分表示的值为 1.625）。
>   3. **值计算**：$
>
>     -1.625 \times 2^2 = -6.5
>     $
>
>   #### 3. 为什么使用隐含的 1？
>   这种方法可以节省 1 位存储空间。例如，对于单精度浮点数，尾数部分有 23 位，通过隐含的 1，这 23 位可以表示小数部分，而不需要存储整数的 1。这一位空间节省可以提高精度，因为比特位完全用来存储小数部分。











==IEEE 754标准中,规格化单精度浮点数的真值为$\begin{align*}(-1)^s \times 1 .f \times 2^{e-127}\end{align*}$==（f是尾数、e是阶码）

==IEEE 754标准中,规格化双精度浮点数的真值为$\begin{align*}(-1)^s \times 1 .f \times 2^{e-1023}\end{align*}$==

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027170819923.png" alt="image-20241027170819923" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

**IEEE 754标准中[==阶码全为0或全为1时的特殊意义==]()**

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027165836268.png" alt="image-20241027165836268" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>



例题:

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027171638644.png" alt="image-20241027171638644" width="85%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027190051370.png" alt="image-20241027190051370" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>



<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027190902334.png" alt="image-20241027190902334" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027192905358.png" alt="image-20241027192905358" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>





##### IEEE875单精度浮点数的表示范围

分为规格化和非规格化的表示范围：



<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027194109031.png" alt="image-20241027194109031" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>

<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027194133396.png" alt="image-20241027194133396" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>



> Q:规格化正负数的阶码取值范围为什么是[1,254]?
>
> A:
>
> 在 IEEE 754 浮点数标准中，单精度浮点数的 **阶码部分**用 8 位二进制表示，这导致阶码字段的二进制值范围为 `0` 到 `255`。然而，其中某些阶码值被保留用于特殊情况，所以规格化数的阶码范围会被限制为 `[1, 254]`。
>
> #### 1. 阶码的偏移量和实际阶码范围
>
> - IEEE 754 使用 **偏移量**（Bias）来表示阶码。对于单精度浮点数，偏移量是 `127`。
> - 因此，阶码字段的实际值 $ E $ 是通过阶码字段值 $ e $ 减去偏移量来计算的，即：
>   $
>   E = e - 127
>   $
>
> #### 2. 阶码字段的取值范围
>
> 阶码字段 $ e $ 的取值范围为 `0` 到 `255`：
>
> - ==**阶码 = 0**：用于表示 **非规格化数**，这类数可以表示极小的数（接近 0）。==
> - ==**阶码 = 255**：用于表示特殊值，包括 **无穷大** 和 **NaN**（非数）。==
>
> 因此，规格化数的阶码字段的有效范围是 `1` 到 `254`，具体范围如下：
>
> - 当 $ e = 1 $ 时，实际阶码 $ E = 1 - 127 = -126 $，这表示规格化数的最小阶码值。
> - 当 $ e = 254 $ 时，实际阶码 $ E = 254 - 127 = 127 $，这表示规格化数的最大阶码值。
>
> #### 3. 规格化数的阶码取值范围 `[1, 254]`
>
> ==规格化数表示的有效阶码范围为 **[-126, 127]**，对应于阶码字段 $ e $ 取值范围 `[1, 254]`。这样就保证了所有规格化数可以表示的浮点数都在有效范围内，而不会与非规格化数、无穷大和 NaN 的编码相冲突。==
>
> #### 总结
>
> 规格化浮点数的阶码范围 `[1, 254]` 是 IEEE 754 标准的一部分设计，它允许使用 0 表示非规格化数，255 表示特殊值，而 `[1, 254]` 则用于常规的规格化浮点数。



<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027194442696.png" alt="image-20241027194442696" width="85%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>



<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027195134264.png" alt="image-20241027195134264" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>



<div align="left" ><img src="https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241027201252827.png" alt="image-20241027201252827" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div>





#### 2.1.4.4 浮点数的加减法

#### 2.1.4.5 浮点数的乘除法




## **2.2 位运算**

## **2.3 运算器**

## **2.4 常见问题**

# **Ⅲ 存储系统**

# **Ⅳ 指令系统**

# 