# **Ⅰ 计算机系统概述**

## **1.2 计算机系统层次结构**

### **1.2.1 计算机硬件的基本组成**

#### 1.2.1.1 冯·诺依曼计算机的结构

​	虚线表示控制和状态反馈，实线表示数据通路

![image-20241020120226224](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120226224.png)



#### **1.2.1.2 现代计算机结构：**

![image-20241020120244325](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120244325.png)



- **==主存储器的基本构成==：**

-- 存储体-存储单元-存储元件（可类比大楼-房间-床位）
-- ==存储单元：存放一串二进制代码==
-- ==存储字：存储单元中二进制代码的组合==
-- ==存储字长：即存储单元中二进制代码的长度（存储字长度）==
-- ==**MAR:存储器地址寄存器，反应存储单元的个数**==
-- ==**MDR:存储器数据寄存器，反应存储字长**==

![image-20241020120303591](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120303591.png)



- **运算器的基本组成：**

![image-20241020120313973](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120313973.png)



**Q&A**

为什么MAR 能反映存储单元的个数？

MAR（Memory Address Register，内存地址寄存器）能够反映存储单元的个数，是因为它用于存储访问内存时的地址，而该地址的位数决定了可以寻址的存储单元数量。

具体来说：

1.地址位数与存储单元的关系

- - MAR的位数决定了它能够表示的地址范围。假设MAR有N位，那么它最多可以表示 ( 2^N ) 个不同的地址。这意味着可以访问 ( 2^N ) 个存储单元。

2.示例

- - 如果MAR是16位，那么它可以表示 ( $2^{16} = 65,536$ ) 个不同的地址。因此，系统可以访问65,536个存储单元（也就是64KB的内存）。
  - 如果MAR是32位，那么它可以表示 ($ 2^{32} = 4,294,967,296 $) 个地址，也就是可以访问4GB的内存。

3.总结

- - MAR的位数决定了系统能够寻址的存储单元数量。位数越多，能访问的存储单元也就越多。因此，MAR的位数反映了系统可以支持的最大存储单元数。





**控制器基本结构 ：**

1.==功能：解释指令、保证指令的按序进行==

完成一条指令需要：取指令 分析指令 执行指令

![image-20241020120436206](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120436206.png)

### ==**1.2.2 计算机硬件的工作原理**==



#### 1.“存储程序”工作方式

“存储程序”工作方式规定,程序执行前,需要将程序所含的指令和数据送入主存储器,一旦程序被启动执行，就无须操作人员的干预，自动逐条完成指令的取出和执行任务。如图 1.4 所示,一个程序的执行就是周而复始地执行一条一条指令的过程。每条指令的执行过程包括:从主存储器中取指令、对指令进行译码、计算下条指令地址、取操作数并执行、将结果送回存储器。

程序执行前，先将程序第一条指令的地址存放到 PC 中，取指令时，将 PC 的内容作为地址访问主存储器。在每条指令执行过程中,都需要计算下条将执行指令的地址,并送至PC。若当前指令为顺序型指令,则下条指令地址为PC的内容加上当前指令的长度;若当前指令为转跳型指令，则下条指令地址为指令中指定的目标地址。当前指令执行完后，根据 PC 的内容到主存储器中取出的是下一条将要执行的指令,因而计算机能周而复始地自动取出并执行一条一条的指令。

![image-20241020131138634](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020131138634.png)







#### 2.从源程序到可执行文件

pass

#### 3.指令执行过程的描述

pass





![image-20241020120514312](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120514312.png)



### **1.2.3 计算机系统的层次结构**

![image-20241020120542108](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120542108.png)



**计算机系统的层次结构：**

![image-20241020120554699](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120554699.png)





**三个级别的语言：**

编译程序：将高级语言编写的源程序全部语句一次全部翻译成机器语言程序，而后再执行机器语言程序（==只需翻译一次==)

解释程序:将源程序的一条语句翻译成对应的机器语言的语句,并立即执行。紧接着再翻译下一句(==每次执行都要翻译==)

以下是机器语言、汇编语言和高级语言的对比表格：



| **特性**       | **机器语言**                         | **汇编语言**                                 | **高级语言**                                |
| -------------- | ------------------------------------ | -------------------------------------------- | ------------------------------------------- |
| **抽象层次**   | 最低（直接与硬件交互）               | 低（与硬件紧密关联）                         | 高（接近人类语言，跨平台）                  |
| **表示形式**   | 二进制代码（0和1）                   | 助记符（如MOV、ADD等）                       | 类似自然语言或数学符号的语句（如if、for等） |
| **执行效率**   | 最高                                 | 高                                           | 较高（需要通过编译器或解释器转换）          |
| **易读性**     | 极低（难以理解和调试）               | 低（需要了解硬件细节）                       | 高（易于阅读、编写和维护）                  |
| **平台依赖性** | 高（与特定处理器架构紧密相关）       | 高（依赖于特定的硬件架构）                   | 低（通常可跨平台）                          |
| **开发效率**   | 最低（编写复杂、耗时）               | 较低（相比机器语言有所改进，但仍需硬件知识） | 最高（大幅提高开发效率）                    |
| **使用场景**   | 硬件驱动、嵌入式系统中的极端性能优化 | 系统软件、驱动程序、嵌入式开发               | 应用软件、跨平台开发、大规模软件项目        |

![image-20241020120612568](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120612568.png)





## **1.3 计算机的主要性能指标**

![image-20241020120624818](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120624818.png)



### **字长**

==字长指的是CPU在一次操作中能够处理的二进制位数。==它通常代表CPU寄存器的宽度和指令集架构的基本操作单位。典型的字长有8位（8-bit），16位（16-bit），32位（32-bit），64位（64-bit）等。字长越长，系统能够直接寻址的内存空间也越大。例如，32位的系统最多可以寻址4GB的内存，而64位系统可以寻址理论上的16EB

### **数据通路带宽**

==是指数据总线一次所能并行传送信息的位数。==数据通路带宽决定了每次内存与CPU之间或其他部件之间能够传输的数据量。例如，一个系统的数据总线带宽是32位，则它一次可以传输32位（4字节）数据。如果是64位的数据总线，则可以一次传输64位（8字节）数据。

### 主存容量

![image-20241020120639851](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120639851.png)

### **运算速度**

**(1) 吞吐量和响应时间**

- ==吞吐量：单位时间内系统能够处理的请求数量。==对于CPU而言，吞吐量通常是每秒钟执行的指令数（Instructions Per Second，IPS）或浮点运算次数（FLOPS）。在多用户或并发任务场景下，吞吐量反映了系统的整体处理能力。示例：如果一台服务器每秒可以处理100个请求，那么它的吞吐量就是100请求/秒
- 响应时间：响应时间是指从发出请求到接收到系统响应之间的时间。

**(2) 主频和CPU时钟周期**

- ==CPU时钟周期：时钟周期是CPU内部完成一项操作的最小时间单位。**主频的倒数。CPU中最小的时间单位。**==示例：如果一个CPU的主频为2GHz，那么它的时钟周期是1/2GHz = 0.5纳秒（ns）。
- ==主频：主频是CPU数字脉冲信号的震荡频率，通常以GHz（千兆赫）为单位表示。==它表示CPU每秒可以完成的时钟周期数。较高的主频通常意味着CPU每秒能完成更多的指令，但不一定反映整体性能。

(3) **CPI**：==执行一条指令所花费的时钟周期数。==

(4) **CPU执行时间**：执行一个程序所花费的时间。==**CPU执行时间（整个程序的耗时）= CPU时钟周期数/主频= （指令条数\*CPI） /主频。 类比:时间=路程/速度**==

![image-20241020120652227](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120652227.png)





==**意CPU的性能(执行时间)取决于三个要素：主频、CPI、指令条数**==



**(5)IPS与FLOPS**

- IPS （Instructions Per Second）:每秒执行多少条指令。
- FLOPS （Floating-point Operations Per Second） :每秒执行多少浮点运算。

![image-20241020120702785](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020120702785.png)

### **基准程序**

基准程序是用来测量计算机处理速度的一种实用程序,以便于被测量的计算机性能可以与运行相同程序的其它计算机性能进行比较。









# **Ⅱ 数据的表示和运算**

## **2.1 数制与编码**

### **2.1.1 进位计数制及其相互转换**

![](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020111002874.png)

#### **1) r进制计数法**

基数：每个数码位所用到的不同符号的个数，r进制的基数为r。

==在进位计数法中，每个数位所用到的不同数码的个数称为基数。==十进制的基数为10 (0~9)，每个数位计满 10就向高位进位，即“逢十进一”。

==每个数码所表示的数值等于该数码本身 乘以一个与它所在数位有关的常数,这个常数称为位权==。一个进位数的数值大小就是它的各位数码按权相加。
$$
\text{一个 }r\text{ 进制数(}K_nK_{n-1}...K_0K_{-1}...K_{-m}\text{)的数值可表示为}\\K_{n}r^{n}+K_{n-1}r^{n-1}+\cdots+K_{0}r^{0}+K_{-1}r^{-1}+\cdots+K_{-m}r^{-m}=\sum_{i=n}^{-m}K_{i}r^{i}
$$
$\text{式中,}r\text{ 是基数;}r^j\text{ 是第 }i\text{ 位的位权;}K_i\text{的取值可以是 }0,1,\cdots,r-1\text{ 共 }r\text{ 个数码中的任意一个。}$



例如任意进制转十进制
$$
二进制：$101.1->1\times2^{2}+0\times2^{0}+1\times2^{-1}=5.5$\\

八进制：$5.4->5\times8^{0}+4\times8^{-1}=5.5$\\

十进制：$5.5->5\times10^{0}+5\times10^{-1}=5.5$ \\

十六进制：$5.8->5\times16^0+8\times16^{-1}=5.5$
$$


#### **2）任意进制转十进制与十进制转任意进制**

![image-20241020112843149](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020112843149.png)

![image-20241020112902004](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020112902004.png)

可以用后缀字母标识一个数的进位计数制，==用 B 表示二进制，用O 表示八进制，用 D 表示十进制（通常直接省略），用 H 表示十六进制，有时也用前缀 0x 表示十六进制数。==



#### **3) 二进制转八进制、十六进制**

1. 对于一个二进制混合数(既包含整数部分，又包含小数部分)，在转换时应以小数点为界。
2. ==其整数部分，从小数点开始往左数，将一串二进制数分为3 位（八进制）一组或4 位（十六进制）一组，在数的最左边可根据需要加“0”补齐；==
3. ==对于小数部分，从小数点开始往右数，也将一串二进制数分为 3 位一组或 4 位一组，在数的最右边也可根据需要加“0”补齐。==
4. 最终使总的位数为3 或 4 的整数倍，然后分别用对应的八进制数或十六进制数取代。

![image-20241020114246189](https://raw.githubusercontent.com/Dean-op/MyPic/main/image/image-20241020114246189.png)



同样,==由八进制数或十六进制数转换为二进制数,只需将每位改为3位或4位二进制数即可(必要时去掉整数最高位或小数最低位的0)。==

八进制数和十六进制数之间的转换也能方便地实现，十六进制数转换为八进制数(或八进制数转换为十六进制数)时,先将十六进制(八进制)数转换为二进制数,然后由二进制数转换为八进制(十六进制)数较方便。

#### **4) 十进制小数转换为二进制小数**

一个十进制数转换为任意进制数，通常采用基数乘除法。这种转换方法对十进制数的整数部分和小数部分将分别进行处理，==对整数部分采用除基取余法，对小数部分采用乘基取整法，==最后将整数部分与小数部分的转换结果拼接起来。

1. **除基取余法（用于整数部分）**

​		**除基取余法**用于将十进制数的**整数部分**转换为任意进制数。

- ==**步骤**：==
  
  1. ==用十进制数除以目标进制的基数。==
  2. ==记录每次除法得到的**余数**，作为目标进制中的一位数。==
  3. ==将除法得到的商继续除以基数，重复上述步骤，直到商为零。==
  4. ==逆序排列所有余数，得到转换后的进制数。==
  
- **示例**：
  将十进制数 **45** 转换为 **二进制**：
  $$
  1:45 \div 2 = 22 , 余数为 1\\
  2:22 \div 2 = 11 , 余数为 0\\
  3:11 \div 2 = 5 , 余数为 1\\
  4:5 \div 2 = 2 , 余数为 1\\
  5:2 \div 2 = 1 , 余数为 0\\
  6:1 \div 2 = 0 , 余数为 1
  $$
  逆序排列余数：**101101**。所以，十进制数45的二进制表示为 **101101**。

2. **乘基取整法（用于小数部分）**

​		**乘基取整法**用于将十进制数的**小数部分**转换为任意进制数。

- ==**步骤**：==
  
  1. ==用小数部分乘以目标进制的基数。==
  2. ==记录每次乘法结果的**整数部分**，作为目标进制中的一位小数。==
  3. ==将乘法结果的小数部分继续乘以基数，重复上述步骤，直到小数部分为零（或达到所需精度）。==
  4. ==顺序排列所有的整数部分，得到小数的转换结果。==
  
- **示例**：
  将十进制小数 **0.625** 转换为 **二进制**：
  $$
  1: 0.625 \times 2 = 1.25  , 整数部分为  1 ，小数部分为  0.25 \\
  2: 0.25 \times 2 = 0.5  , 整数部分为  0 ，小数部分为  0.5 \\
  3: 0.5 \times 2 = 1.0  , 整数部分为  1 ，小数部分为  0
  $$
  顺序排列整数部分：**101**。所以，十进制小数0.625的二进制表示为 **0.101**。

将整数部分的转换结果与小数部分的转换结果拼接在一起，得到完整的进制转换结果。

例如，十进制数 **45.625** 转换为二进制数：

- 整数部分：**101101**
- 小数部分：**0.101**

结果为：**101101.101**。

**总结**

- ==**除基取余法**用于整数部分，通过反复除以目标基数取余来获取进制数的各位，结果按逆序排列。==
- ==**乘基取整法**用于小数部分，通过反复乘以目标基数取整数来获取进制数的小数部分，结果按顺序排列。==



注意：在计算机中,小数和整数不一样,整数可以连续表示==,但小数是离散的,所以并不是每个十进制小数都可以准确地用二进制表示==。例如0.3,无论经过多少次乘二取整转换都无法得到精确的结果。但任意一个二进制小数都可以用十进制小数表示,希望读者引起重视。





### **2.1.2 定点数的编码表示**

#### 2.1.2.1 真值和机器数

在日常生活中==,通常用正号、负号来分别表示正数(正号可省略)和负数,如+15、-8等。这种带“+”或“-”符号的数称为真值。==真值是机器数所代表的实际值。

==在计算机中，通常将数的符号和数值部分一起编码，将数据的符号数字化，通常用“0”表示“正”，用“1”表示“负”。这种把符号“数字化”的数称为机器数。==常用的有原码、补码和反码表示法。如 0,101(这里的逗号“，”仅为区分符号位与数值位)表示+5。

#### 2.1.2.2 机器数的定点表示

==根据小数点的位置是否固定，在计算机中有两种数据格式：定点表示和浮点表示。==

在现代计算机中，==通常用补码整数表示整数，用原码小数表示浮点数的尾数部分，用移码表示浮点数的阶码部分，==历年统考真题的命题信息也主要落在这个范畴之内。









#### 2.1.2.3 原码、补码、反码、移码







### **2.1.3 整数的表示**

### **2.1.4 C语言中的整数类型及类型转换**

## **2.2 运算方法和运算电路**

## **2.3 浮点数的表示与运算**

## **2.4 常见问题**

# **Ⅲ 存储系统**

# **Ⅳ 指令系统**

# 